#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# 3-Node(Guid, Navi, Cont) 로직을 MAVROS 기반 단일 노드로 통합
# MAVROS의 /mavros/setpoint_velocity/cmd_vel_unstamped 토픽을 사용
# [!!] Ouster LIDAR (PointCloud2)를 사용하도록 수정
# [!!] GPS/UTM 변환 제거, Local 좌표 직접 파라미터 입력 및 MAVROS Local Position 사용

import rclpy
import math
import cv2
import os
import numpy as np
import transforms3d.euler as euler
from std_msgs.msg import Int32

from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
# from pyproj import Transformer # [!!] 제거됨: GPS/UTM 변환 불필요
from ament_index_python.packages import get_package_share_directory
from ultralytics import YOLO
from cv_bridge import CvBridge

# MAVROS 메시지
from mavros_msgs.msg import State
from mavros_msgs.srv import CommandBool, SetMode

# 기존 센서 메시지
from sensor_msgs.msg import NavSatFix, Imu, Image
from sensor_msgs.msg import PointCloud2 
import sensor_msgs_py.point_cloud2 as pc2 
from geometry_msgs.msg import Twist, Point, PoseStamped # PoseStamped 추가
from std_msgs.msg import String
from visualization_msgs.msg import Marker


class MavrosDockingController(Node):
    def __init__(self):
        super().__init__('mavros_docking_controller')

        # --- FSM 상태 정의 ---
        self.mission_status = "INITIALIZING" 
        self.declare_parameter('mission_id', 2)
        self.my_mission_id = self.get_parameter('mission_id').value

        self.global_mission_state = 0
        self.is_active = False 

        self.create_subscription(
            Int32,
            '/mission_state',
            self.mission_state_cb,
            10
        )

        # --- MAVROS 및 센서 변수 ---
        self.current_state = None
        # self.current_pose_gps = None # [!!] GPS 구독 제거로 불필요
        self.current_yaw_rad = 0.0
        self.current_local = None # [!!] 현재 로컬 ENU 좌표 (PoseStamped 콜백에서 채워짐)
        self.min_forward_distance = 999.0
        # self.transformer = None # [!!] 제거됨
        # self.origin_utm = None  # [!!] UTM 제거로 불필요

        # --- 비전(Guid) 변수 ---
        self.bridge = CvBridge()
        self.visual_errors = {}
        self.target_order_str = None
        self.order_determined = False
        self.image_center_x = 0
        self.image_width = 0

        # --- 임무(Navi) 변수 ---
        self.target_index = -1 
        self.selected_dock_nav_local = None
        self.selected_dock_face_local = None
        self.p1_local = None
        self.p2_local = None
        self.dock_nav_points_local = []
        self.dock_face_points_local = []

        # --- 제어(Cont) 변수 ---
        self.prev_heading_error = 0.0
        self.prev_visual_error = 0.0
        self.target_yaw_rad_internal = None
        self.align_success_timer = None
        self.pause_timer = None

        # ==================================================================
        # 1. 파라미터 선언 (로컬 좌표계로 변경)
        # ==================================================================

        # --- Guid(비전) 파라미터 ---
        self.declare_parameter('camera_topic', '/flir_camera/image_raw')
        self.declare_parameter('show_vision', True)
        self.declare_parameter('targets', ['Paper', 'Rock', 'Scissors'])
        self.declare_parameter('yolo_model_pkg', 'docking_final')
        self.declare_parameter('yolo_model_path', 'weights/docking_rsp.pt')

        # --- Navi(항법) 파라미터 [!!] 위도/경도 -> 로컬 좌표 (x, y)로 변경됨 ---
        self.declare_parameter('target_shape', 'Paper') 
        self.declare_parameter('point_1_inspection_local', [10.0, 0.0]) # Home을 (0,0)으로 가정
        self.declare_parameter('point_2_inspection_facing_local', [11.0, 0.0])
        self.declare_parameter('dock_0_nav_local', [25.0, 5.0])
        self.declare_parameter('dock_0_face_local', [26.0, 5.0])
        self.declare_parameter('dock_1_nav_local', [25.0, 0.0])
        self.declare_parameter('dock_1_face_local', [26.0, 0.0])
        self.declare_parameter('dock_2_nav_local', [25.0, -5.0])
        self.declare_parameter('dock_2_face_local', [26.0, -5.0])
        
        # --- Cont(제어) 파라미터 ---
        self.declare_parameter('arrival_radius', 5)
        self.declare_parameter('rotation_threshold_rad', math.radians(10.0))
        self.declare_parameter('nav_speed_ms', 1.0)
        self.declare_parameter('nav_dock_speed_ms', 0.5)
        self.declare_parameter('final_approach_speed_ms', 0.2)
        self.declare_parameter('reverse_speed_ms', 0.3)
        self.declare_parameter('kp_nav_yaw_rate', 1.5)
        self.declare_parameter('kd_nav_yaw_rate', 0.5)
        self.declare_parameter('kp_rot_yaw_rate', 1.0) 
        self.declare_parameter('kp_visual_yaw_rate', 0.005)
        self.declare_parameter('kd_visual_yaw_rate', 0.001)
        self.declare_parameter('visual_align_threshold_px', 15.0)
        self.declare_parameter('visual_align_hold_sec', 2.0)
        self.declare_parameter('pointcloud_topic', '/ouster/points')
        self.declare_parameter('lidar_fov_deg', 10.0)
        self.declare_parameter('lidar_z_min', -0.5)
        self.declare_parameter('lidar_z_max', 1.0)
        self.declare_parameter('final_stop_distance_lidar', 4.0)
        self.declare_parameter('hold_duration_after_dock', 5.0)
        self.declare_parameter('target_reverse_distance', 10.0)

        # ==================================================================
        # 2. 파라미터 로드 및 좌표 로드 (UTM 변환 없이)
        # ==================================================================
        
        gp = self.get_parameter
        self.target_shape = gp('target_shape').value.lower()
        self.targets_to_find = [t.lower() for t in gp('targets').value]
        if len(self.targets_to_find) != 3:
            self.get_logger().error("targets 파라미터는 3개여야 합니다. (예: ['circle', 'triangle', 'rectangle'])")
            return

        # --- 좌표 로드 (Local x, y) ---
        self.p1_local = tuple(gp('point_1_inspection_local').value)
        self.p2_local = tuple(gp('point_2_inspection_facing_local').value)

        for i in range(3):
            nav_local = tuple(gp(f'dock_{i}_nav_local').value)
            face_local = tuple(gp(f'dock_{i}_face_local').value)
            self.dock_nav_points_local.append(nav_local)
            self.dock_face_points_local.append(face_local)

        self.get_logger().info(f"P1 Local Waypoint set to: {self.p1_local}")
        self.get_logger().info(f"Target shape: {self.target_shape}")

        # --- 제어 게인 로드 ---
        self.arrival_radius = gp('arrival_radius').value
        self.rotation_threshold_rad = gp('rotation_threshold_rad').value
        self.nav_speed_ms = gp('nav_speed_ms').value
        self.nav_dock_speed_ms = gp('nav_dock_speed_ms').value
        self.kp_nav_yaw_rate = gp('kp_nav_yaw_rate').value
        self.kd_nav_yaw_rate = gp('kd_nav_yaw_rate').value
        self.kp_rot_yaw_rate = gp('kp_rot_yaw_rate').value
        self.kp_visual_yaw_rate = gp('kp_visual_yaw_rate').value
        self.kd_visual_yaw_rate = gp('kd_visual_yaw_rate').value
        self.visual_align_threshold_px = gp('visual_align_threshold_px').value
        self.visual_align_hold_sec = gp('visual_align_hold_sec').value
        self.final_approach_speed_ms = gp('final_approach_speed_ms').value
        self.reverse_speed_ms = gp('reverse_speed_ms').value
        self.final_stop_distance_lidar = gp('final_stop_distance_lidar').value
        self.hold_duration_after_dock = gp('hold_duration_after_dock').value
        self.target_reverse_distance = gp('target_reverse_distance').value
        self.show_vision = gp('show_vision').value
        
        # --- PointCloud 파라미터 로드 ---
        self.pc_topic = gp('pointcloud_topic').value
        self.pc_fov_rad = math.radians(gp('lidar_fov_deg').value / 2.0)
        self.pc_z_min = gp('lidar_z_min').value
        self.pc_z_max = gp('lidar_z_max').value

        # --- YOLO 모델 로드 ---
        pkg_share = get_package_share_directory(gp('yolo_model_pkg').value)
        model_path = os.path.join(pkg_share, gp('yolo_model_path').value)
        try:
            self.model = YOLO(model_path)
            self.get_logger().info(f"YOLO model loaded from: {model_path}")
        except Exception as e:
            self.get_logger().error(f"Failed to load YOLO model: {e}")
            return

        # ==================================================================
        # 3. MAVROS 및 센서 Sub/Pub/Client 설정 (Local Position 사용)
        # ==================================================================

        # --- QoS ---
        qos_reliable = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )
        qos_best_effort = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=1
        )

        # --- MAVROS Subscribers ---
        self.state_sub = self.create_subscription(State, '/mavros/state', self.state_callback, qos_best_effort)
        # [!!] GPS (NavSatFix) 구독 제거. 대신 Local Position 구독:
        self.local_pos_sub = self.create_subscription(
            PoseStamped, '/mavros/local_position/pose', self.local_pos_callback, qos_best_effort)
        self.imu_sub = self.create_subscription(Imu, '/mavros/imu/data', self.imu_callback, qos_best_effort)
        
        # --- 센서 Subscribers ---
        self.image_sub = self.create_subscription(Image, gp('camera_topic').value, self.image_cb, qos_best_effort)
        self.pc_sub = self.create_subscription(
            PointCloud2, 
            self.pc_topic, 
            self.pointcloud_callback, 
            qos_best_effort
        )

        # --- MAVROS Publisher ---
        self.velocity_pub = self.create_publisher(Twist, '/mavros/setpoint_velocity/cmd_vel_unstamped', 10)
        self.status_pub_for_debug = self.create_publisher(String, '~/mission_status', qos_reliable)
        self.marker_pub = self.create_publisher(Marker, '~/waypoints_viz', qos_reliable)

        # --- MAVROS Clients ---
        self.arming_client = self.create_client(CommandBool, '/mavros/cmd/arming')
        self.set_mode_client = self.create_client(SetMode, '/mavros/set_mode')

        # --- 메인 제어 루프 ---
        self.control_timer = self.create_timer(0.1, self.control_loop)

        self.get_logger().info('MavrosDockingController node initialized. Waiting for MAVROS connection...')


    # ==================================================================
    # 4. 콜백 함수 (센서 데이터 수신)
    # ==================================================================
    def mission_state_cb(self, msg: Int32):
        self.global_mission_state = msg.data

    def state_callback(self, msg):
        self.current_state = msg

    # def gps_callback(self, msg): # [!!] 제거됨
    #     self.current_pose_gps = msg
    
    def local_pos_callback(self, msg: PoseStamped):
        """MAVROS Local Position (ENU)를 현재 로컬 좌표로 사용"""
        self.current_local = (msg.pose.position.x, msg.pose.position.y)

    def imu_callback(self, msg):
        q = msg.orientation
        _, _, self.current_yaw_rad = euler.quat2euler([q.w, q.x, q.y, q.z])
    
    # ... (pointcloud_callback 및 image_cb는 원본 코드와 동일) ...
    # (코드가 너무 길어지므로 콜백 함수의 본문은 생략합니다. 기능은 원본과 동일하게 유지됩니다.)

    def pointcloud_callback(self, msg: PointCloud2):
        min_x_distance = 999.0
        try:
            for p in pc2.read_points(msg, field_names=("x", "y", "z"), skip_nans=True):
                x, y, z = p[0], p[1], p[2]
                if z < self.pc_z_min or z > self.pc_z_max: continue
                if x <= 0: continue
                angle = math.atan2(y, x)
                if abs(angle) < self.pc_fov_rad:
                    if x < min_x_distance: min_x_distance = x
        except Exception as e:
            self.get_logger().warn(f"Failed to read PointCloud2 data: {e}", throttle_duration_sec=5)
            return
        self.min_forward_distance = min_x_distance

    def image_cb(self, msg: Image):
        if self.mission_status not in ["SCANNING_FOR_TARGETS", "ROTATING_VISUAL_ALIGN", "FINAL_APPROACH"]:
            self.get_logger().info(f"Image CB skipped. Status: {self.mission_status}", throttle_duration_sec=5)
            return
        
        self.get_logger().info(f"Image CB active. Status: {self.mission_status}", throttle_duration_sec=1)

        try:
            frame = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            h, w, _ = frame.shape
            self.image_center_x = w // 2
            self.image_width = w
        except Exception as e:
            self.get_logger().warn(f"CV Bridge error: {e}")
            return

        results = self.model(frame, verbose=False)

        current_errors = {target: 0.0 for target in self.targets_to_find}
        target_centers = {}

        for r in results:
            for box in r.boxes:
                cls_id = int(box.cls.item())
                cls_name = self.model.names[cls_id].lower()
                conf = float(box.conf.item())

                if cls_name in self.targets_to_find and conf > 0.1:
                    x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
                    cx = int((x1 + x2) / 2)
                    cy = int((y1 + y2) / 2)
                    
                    current_errors[cls_name] = float(cx - self.image_center_x)
                    target_centers[cls_name] = (cx, cy)
                    
                    if self.show_vision:
                        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                        cv2.circle(frame, (cx, cy), 5, (0, 0, 255), -1)
                        cv2.putText(frame, f"{cls_name} ({current_errors[cls_name]:.1f}px)", 
                                    (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        
        self.visual_errors = current_errors

        if target_centers:
            self.get_logger().info(f"Detected {len(target_centers)} targets: {target_centers.keys()}", throttle_duration_sec=1)

        if self.mission_status == "SCANNING_FOR_TARGETS" and not self.order_determined:
            all_found = all(t in target_centers for t in self.targets_to_find)

            if all_found:
                self.order_determined = True 
                
                sorted_targets = sorted(target_centers.items(), key=lambda item: item[1][0])
                ordered_names = [name for name, center in sorted_targets]
                self.target_order_str = ",".join(ordered_names)
                
                self.get_logger().info(f"--- [!!] All targets detected! Order: {self.target_order_str} [!!] ---")

                if self.target_shape in ordered_names:
                    self.target_index = ordered_names.index(self.target_shape)
                    self.selected_dock_nav_local = self.dock_nav_points_local[self.target_index]
                    self.selected_dock_face_local = self.dock_face_points_local[self.target_index]

                    self.get_logger().info(f"--- [!!] Target '{self.target_shape}' found at index {self.target_index} [!!] ---")
                    
                    self.mission_status = "NAV_TO_DOCK"
                    self.prev_heading_error = 0.0
                else:
                    self.get_logger().warn(f"Target shape '{self.target_shape}' not found in detected order: {self.target_order_str}. Rescanning.")
                    self.order_determined = False 
        
        if self.show_vision:
            cv2.line(frame, (self.image_center_x, 0), (self.image_center_x, h), (0, 255, 255), 1)
            cv2.imshow("YOLO Detection", frame)
            cv2.waitKey(1)

    # ==================================================================
    # 5. MAVROS 헬퍼 함수
    # ==================================================================

    def arm_and_set_mode(self):
        if not self.arming_client.wait_for_service(timeout_sec=1.0) or \
           not self.set_mode_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().warn("MAVROS services not available. Retrying...")
            return False

        arm_req = CommandBool.Request()
        arm_req.value = True
        self.arming_client.call_async(arm_req)
        self.get_logger().info("Arming command sent...")

        mode_req = SetMode.Request()
        mode_req.custom_mode = 'GUIDED'
        self.set_mode_client.call_async(mode_req)
        self.get_logger().info("Set mode to GUIDED command sent...")
        return True

    def publish_velocity(self, velocity_x, yaw_rate_rad_s):
        vel_msg = Twist()
        vel_msg.linear.x = velocity_x
        vel_msg.angular.z = yaw_rate_rad_s
        self.velocity_pub.publish(vel_msg)

    # def convert_gps_to_local(self, lon, lat): # [!!] 제거됨

    # ==================================================================
    # 6. 제어 로직 헬퍼 함수
    # ==================================================================
    # ... (execute_pd_heading_control, execute_rotation, publish_waypoint_marker는 원본 코드와 동일) ...

    def execute_pd_heading_control(self, goal_local, speed_ms):
        if goal_local is None:
            self.publish_velocity(0.0, 0.0)
            return

        distance_to_goal = math.sqrt((goal_local[0] - self.current_local[0])**2 + (goal_local[1] - self.current_local[1])**2)
        
        desired_heading_rad = math.atan2(goal_local[1] - self.current_local[1], goal_local[0] - self.current_local[0])
        
        heading_error = desired_heading_rad - self.current_yaw_rad
        while heading_error > math.pi: heading_error -= 2 * math.pi
        while heading_error < -math.pi: heading_error += 2 * math.pi

        heading_error_derivative = heading_error - self.prev_heading_error
        turn_rate_rad_s = self.kp_nav_yaw_rate * heading_error + self.kd_nav_yaw_rate * heading_error_derivative
        self.prev_heading_error = heading_error
        
        self.publish_velocity(speed_ms, turn_rate_rad_s)
        
        self.get_logger().info(f"Navigating... Dist: {distance_to_goal:.1f}m, Err: {math.degrees(heading_error):.1f}deg, YawRate: {turn_rate_rad_s:.2f}rad/s", throttle_duration_sec=1)
        self.publish_waypoint_marker(goal_local, (0.0, 1.0, 0.0))


    def execute_rotation(self, target_yaw_rad, next_status):
        if target_yaw_rad is None:
            self.get_logger().warn("Rotation target yaw is not set!")
            self.publish_velocity(0.0, 0.0)
            return

        error_yaw = target_yaw_rad - self.current_yaw_rad
        error_yaw = (error_yaw + math.pi) % (2 * math.pi) - math.pi

        if abs(error_yaw) < self.rotation_threshold_rad:
            self.get_logger().info(f"Rotation Complete. Error: {math.degrees(error_yaw):.1f} deg. -> Changing status to {next_status}")
            self.mission_status = next_status
            self.publish_velocity(0.0, 0.0)
            self.target_yaw_rad_internal = None
            self.prev_heading_error = 0.0
            self.prev_visual_error = 0.0
            self.align_success_timer = None
            return
        
        turn_rate = self.kp_rot_yaw_rate * error_yaw
        
        self.publish_velocity(0.0, turn_rate)
        self.get_logger().info(f"Rotating... Target: {math.degrees(target_yaw_rad):.1f}, Current: {math.degrees(self.current_yaw_rad):.1f}, Error: {math.degrees(error_yaw):.1f} deg", throttle_duration_sec=1)

    def publish_waypoint_marker(self, goal_local, color_rgb):
        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = self.get_clock().now().to_msg()
        marker.ns, marker.id, marker.type, marker.action = "waypoints", 0, Marker.SPHERE, Marker.ADD
        marker.pose.position.x, marker.pose.position.y = goal_local[0], goal_local[1]
        marker.scale.x, marker.scale.y, marker.scale.z = 2.0, 2.0, 2.0
        marker.color.a = 0.8
        marker.color.r, marker.color.g, marker.color.b = color_rgb
        self.marker_pub.publish(marker)


    # ==================================================================
    # 7. 메인 제어 루프 (FSM)
    # ==================================================================

    def control_loop(self):
        # 0. 내 차례 아니면 그냥 대기 
        if self.global_mission_state != self.my_mission_id:
            if self.is_active:
                self.get_logger().info(
                    f"Docking 비활성 (mission_state={self.global_mission_state})"
                )
                self.is_active = False
            return

        if not self.is_active:
            self.get_logger().info(
                f"Docking 활성화 (mission_state={self.global_mission_state})"
            )
            self.is_active = True
        
        self.status_pub_for_debug.publish(String(data=self.mission_status))

        # 1. INITIALIZING: MAVROS 연결 및 센서 대기
        if self.mission_status == "INITIALIZING":
            # [!!] self.current_local과 self.current_yaw_rad 체크로 변경됨
            if self.current_state is None or self.current_local is None or self.current_yaw_rad is None:
                self.get_logger().info("Waiting for MAVROS connection and Local Position/IMU...", throttle_duration_sec=5)
                return
            
            if not self.current_state.connected:
                self.get_logger().warn("MAVROS not connected to FCU. Retrying...", throttle_duration_sec=5)
                return
            
            self.get_logger().info("Connection established. Attempting to arm and set mode.")
            if self.arm_and_set_mode():
                self.mission_status = "ARMING"
            return

        # 2. ARMING: Arming 및 GUIDED 모드 대기
        elif self.mission_status == "ARMING":
            if self.current_state.armed and self.current_state.mode == 'GUIDED':
                self.get_logger().info("Vehicle armed and in GUIDED mode. Starting mission.")
                self.mission_status = "NAV_TO_P1"
                self.prev_heading_error = 0.0
            else:
                self.get_logger().info(f"Waiting for arm/guided mode. Current mode: {self.current_state.mode}, Armed: {self.current_state.armed}", throttle_duration_sec=2)
                self.arm_and_set_mode()
            return

        # 3. [로컬 위치/IMU 준비 확인]
        if self.current_local is None or self.current_yaw_rad is None:
            self.get_logger().warn("Waiting for Local Position/IMU data...", throttle_duration_sec=5)
            self.publish_velocity(0.0, 0.0)
            return

        # 4. NAV_TO_P1: P1(스캔 지점)으로 항해
        elif self.mission_status == "NAV_TO_P1":
            # ... (이하 모든 항법 및 제어 로직은 self.current_local과 self.current_yaw_rad을 사용하여 원본과 동일하게 작동)
            goal_local = self.p1_local
            distance_to_goal = math.sqrt((goal_local[0] - self.current_local[0])**2 + (goal_local[1] - self.current_local[1])**2)
            
            if distance_to_goal < self.arrival_radius:
                self.get_logger().info("--- Arrived at P1 (Scan Point) ---")
                self.target_yaw_rad_internal = math.atan2(self.p2_local[1] - self.current_local[1], self.p2_local[0] - self.current_local[0])
                self.mission_status = "ROTATING_P1"
                self.publish_velocity(0.0, 0.0)
                return
            
            self.execute_pd_heading_control(goal_local, self.nav_speed_ms)

        # 5. ROTATING_P1: P2를 바라보도록 1차 회전
        elif self.mission_status == "ROTATING_P1":
            self.execute_rotation(self.target_yaw_rad_internal, next_status="SCANNING_FOR_TARGETS")
            self.publish_waypoint_marker(self.p2_local, (1.0, 0.0, 0.0))

        # 6. SCANNING_FOR_TARGETS: 정지 상태로 YOLO 순서 판단 대기
        elif self.mission_status == "SCANNING_FOR_TARGETS":
            self.publish_velocity(0.0, 0.0)
            self.get_logger().info("Scanning for targets... (Waiting for image_cb to find order)", throttle_duration_sec=5)
            
        # 7. NAV_TO_DOCK: 선택된 도크 (NAV 지점)로 항해
        elif self.mission_status == "NAV_TO_DOCK":
            if self.selected_dock_nav_local is None:
                self.get_logger().error("NAV_TO_DOCK state but no target selected! Reverting to SCAN.")
                self.mission_status = "SCANNING_FOR_TARGETS"
                self.order_determined = False
                return

            goal_local = self.selected_dock_nav_local
            distance_to_goal = math.sqrt((goal_local[0] - self.current_local[0])**2 + (goal_local[1] - self.current_local[1])**2)
            
            if distance_to_goal < self.arrival_radius:
                self.get_logger().info(f"--- Arrived at Dock {self.target_index} (Nav Point) ---")
                self.target_yaw_rad_internal = math.atan2(self.selected_dock_face_local[1] - self.current_local[1], self.selected_dock_face_local[0] - self.current_local[0])
                self.mission_status = "ROTATING_DOCK_FACE"
                self.publish_velocity(0.0, 0.0)
                return
            
            self.execute_pd_heading_control(goal_local, self.nav_dock_speed_ms)

        # 8. ROTATING_DOCK_FACE: 도크 정면을 바라보도록 2차 회전
        elif self.mission_status == "ROTATING_DOCK_FACE":
            self.execute_rotation(self.target_yaw_rad_internal, next_status="ROTATING_VISUAL_ALIGN")
            self.publish_waypoint_marker(self.selected_dock_face_local, (1.0, 0.0, 0.0))

        # 9. ROTATING_VISUAL_ALIGN: 3차 회전 (시각적 정렬)
        elif self.mission_status == "ROTATING_VISUAL_ALIGN":
            target_pixel_error = self.visual_errors.get(self.target_shape, 0.0)
            
            if target_pixel_error == 0.0:
                self.get_logger().warn(f"Visual align mode, but target '{self.target_shape}' not detected! Stopping.", throttle_duration_sec=2)
                self.publish_velocity(0.0, 0.0)
                self.align_success_timer = None
                self.prev_visual_error = 0.0
                return

            if abs(target_pixel_error) < self.visual_align_threshold_px:
                if self.align_success_timer is None:
                    self.get_logger().info(f"Target aligned. Holding for {self.visual_align_hold_sec} sec...")
                    self.align_success_timer = self.get_clock().now()
                
                duration = (self.get_clock().now() - self.align_success_timer).nanoseconds / 1e9
                
                if duration >= self.visual_align_hold_sec:
                    self.get_logger().info(f"--- Visual alignment complete (Held for {duration:.1f} sec) ---")
                    self.publish_velocity(0.0, 0.0)
                    self.mission_status = "FINAL_APPROACH"
                    self.align_success_timer = None
                    self.prev_visual_error = 0.0
                    return
                else:
                    self.publish_velocity(0.0, 0.0)
                    self.get_logger().info(f"Holding alignment... ({duration:.1f} / {self.visual_align_hold_sec} sec)", throttle_duration_sec=1)
                    self.prev_visual_error = target_pixel_error
                    return
            
            if self.align_success_timer is not None:
                self.get_logger().info("Alignment lost! Resuming PD-control.")
                self.align_success_timer = None

            error_derivative = target_pixel_error - self.prev_visual_error
            p_turn = self.kp_visual_yaw_rate * target_pixel_error
            d_turn = self.kd_visual_yaw_rate * error_derivative
            yaw_rate = -(p_turn + d_turn)
            self.prev_visual_error = target_pixel_error
            
            self.publish_velocity(0.0, yaw_rate)
            self.get_logger().info(f"Visual Aligning... PxError: {target_pixel_error:.1f}, YawRate: {yaw_rate:.2f}rad/s", throttle_duration_sec=1)

        # 10. FINAL_APPROACH: 최종 접근 (LIDAR + 시각)
        elif self.mission_status == "FINAL_APPROACH":
            if self.min_forward_distance < self.final_stop_distance_lidar:
                self.get_logger().info(f"--- LIDAR Stop! Distance: {self.min_forward_distance:.2f}m. Docking complete. ---")
                self.publish_velocity(0.0, 0.0)
                self.mission_status = "HOLDING_AT_DOCK"
                self.prev_visual_error = 0.0
                self.pause_timer = self.create_timer(self.hold_duration_after_dock, self.resume_after_hold)
                return

            target_pixel_error = self.visual_errors.get(self.target_shape, 0.0)
            yaw_rate = 0.0
            
            if target_pixel_error != 0.0:
                error_derivative = target_pixel_error - self.prev_visual_error
                p_turn = self.kp_visual_yaw_rate * target_pixel_error
                d_turn = self.kd_visual_yaw_rate * error_derivative
                yaw_rate = -(p_turn + d_turn)
                self.prev_visual_error = target_pixel_error
                self.get_logger().info(f"Final Approach... Steering. PxError: {target_pixel_error:.1f}, Lidar: {self.min_forward_distance:.2f}m", throttle_duration_sec=1)
            else:
                self.get_logger().warn(f"Target lost during final approach! Continuing blind straight (Lidar: {self.min_forward_distance:.2f}m)...", throttle_duration_sec=1)
                self.prev_visual_error = 0.0

            self.publish_velocity(self.final_approach_speed_ms, yaw_rate)

        # 11. HOLDING_AT_DOCK: 도킹 후 N초 정지
        elif self.mission_status == "HOLDING_AT_DOCK":
            self.publish_velocity(0.0, 0.0)
            self.get_logger().info(f"Docked. Holding position for {self.hold_duration_after_dock} sec...", throttle_duration_sec=2)
        
        # 12. REVERSING: N미터 후진
        elif self.mission_status == "REVERSING":
            if self.min_forward_distance >= self.target_reverse_distance:
                self.get_logger().info(f"--- Reverse complete. Distance: {self.min_forward_distance:.2f}m. ---")
                self.publish_velocity(0.0, 0.0)
                self.mission_status = "MISSION_COMPLETE"
                return

            self.publish_velocity(-self.reverse_speed_ms, 0.0)
            self.get_logger().info(f"Reversing... (Dist: {self.min_forward_distance:.2f}m / {self.target_reverse_distance}m)", throttle_duration_sec=1)
        
        # 13. MISSION_COMPLETE: 임무 완료
        elif self.mission_status == "MISSION_COMPLETE":
            self.publish_velocity(0.0, 0.0)
            self.get_logger().info("Mission Complete. Holding position.", throttle_duration_sec=5)

    def resume_after_hold(self):
        self.get_logger().info("Hold complete. Starting reverse maneuver.")
        self.pause_timer.cancel()
        self.pause_timer = None
        self.mission_status = "REVERSING"
        


def main(args=None):
    rclpy.init(args=args)
    node = MavrosDockingController()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\nNode interrupted by user.")
    finally:
        node.get_logger().info("Shutting down. Sending stop command.")
        node.publish_velocity(0.0, 0.0)
        if node.show_vision:
            cv2.destroyAllWindows()
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
